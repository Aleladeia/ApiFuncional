Descrição passo a passo do processo de desenvolvimento da API

====== Criando Projeto ======
Primeiramente criamos o projeto ApiFuncional, na primeira aula deste Módulo -> Manipulando operações no banco de dados.

Em sequência apagamos a controller e classe que veio como base do projeto para ele ficar basicamente limpo, vazio,
após isso criamos o diretório Models onde vamos criar nossas entidades. 

====== Criando Entidade ======
A primeira entidade criada foi a de Produtos com as propriedades (Id, Nome, Preco, QuantidaEstoque e Descricao) além
das propriedades adicionamos algumas DataAnnotations, para ID, colocamos [Key], para as demais colocamos  a required
[Required(ErrorMessage = "O campo {0} é obrigatório")], além dela colocamos no preço uma DataAnnotation de Range
[Range(1, int.MaxValue, ErrorMessage = "O preço deve ser maior que zero")]

====== Configurando EF ======
Depois deste processo configuramos o EF Core, através da instalação de pacotes via Package Manager com os seguintes comandos
Install-Package Microsoft.EntityFrameworkCore.SqlServer, Fornece o suporte ao SQLServer
Install-Package Microsoft.EntityFrameworkCore.Design, serve para gerar os scripts
Install-Package Microsoft.EntityFrameworkCore.Tools, para suporte as funcionalidades de geração do próprio EF Core

Após instalar conferir as versões dos pacotes se batem com a versão do .Net Framework, se for o Net8.0 os pacotes devem ser
na versão 8. alguma coisa para evitar problemas e para que tudo funcione corretamente

Após isso adicionamos o diretório Data, para criarmos nosso DbContext, criamos então a ApiDbContext
está classe herda de DbContext do EntityFrameworkCore, e depois criamos o construtor da classe com alguns parametros
no caso passamos o parametro DbContextOptions que é o que nos permite definir a connection string e etc. Onde passamos para 
a classe base DbContext as opções pra saber onde conectar qual o banco e etc, o construtor ficou assim.
public ApiDbContext(DbContextOptions<ApiDbContext> options) : base(options){}

Depois do DbContext criado, passamos para a configuração da nossa Program.cs para dar suporte ao DbContext/SQLServer, para
isso adicionamos o seguinte código acima da var app = builder.Build(); Segue o código abaixo.
builder.Services.AddDbContext<ApiDbContext>(options =>
{
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"));
});

Este código acima adiciona o suporte ao DbContext, passamos a classe que ta implementando ele, definimos suas options
passando para usar o SqlServer e  para que ele vá até o arquivo de configuração do projeto que é o appsettings.json e pegue
a ConnectionString armazenada na chave DefaultConnection e vai usar ela como conexão do banco de dados.

====== Implementando Connection String ======
Após configurar todo o suporte ao EF, precisamos implementar a conexão do nosso banco de dados, para isso vamos ao arquivo de
configuração do projeto appsettings.json e adicionamos as seguintes chaves logo após "AllowedHosts": "*" passamos uma virgula e 
vamos para a próxima linha onde implementamos nossa connection string, ficou desta forma.

"ConnectionStrings": {
    "DefaultConnecion": "Server=(localdb)\\mssqllocaldb;Database=ApiFuncional;Trusted_Connection=True;MultipleActiveResultSets=true"
 }

 ====== Mapeando Uma Entidade ======
 Para isso vamos a nossa classe ApiDbContext e abaixo do construtor vamos criar uma propriedade do tipo Dbset de Produto
 ficando da seguinte forma public DbSet<Produto> Produtos{ get; set; }, isso indica ao DbContext que queremos criar uma tabela
 com as propriedades dessa classe, que no caso é a classe Produto, e ele já aproveita e segue as recomendações dos DataAnotattions

 Após isso precisamos adicionar uma migration, para isso vamos ao Console PM (Package Manager) e executamos o comando 
 Add-Migration "NOME", utilizamos o nome Inicial neste primeiro caso, após execuat o comando podemos observar que um diretório
 Migrations foi criado e nele consta 2 arquivos 1 com o mapeamento da entidade Produtos que é a configuração inicial e 1 outro
 arquivo chamado de Snapshot que é basicamente uma foto de como estava antes e como ficou depois, e sempre que vamos mexendo criando
 novas migrations ele vai gerando estas snapshots para saber como era o estado da aplicação antes e como ficou depois, permitindo 
 assim desfazer uma migration e volta-la para o estado anterior.

 Uma alternativa para o comando Add-Migration "NOME" é o comando dotnet ef migrations add "NOME" no Console e não no PM.

 ====== Criando o Banco de dados ======
 Após criar a migration podemos aplica-la no nosso banco de dados, desde que o endereço informado na connectionStrings esteja 
 apontando para um banco que funcione, nessa hora pode acontecer um problema. O comando para fazer a aplicação é o seguinte
 Update-Database este comando vai conectar ao banco para criar a tabela, e caso o banco não exista também vai cria-lo
 conectar nele e criar a tabela, se ele não conseguir fazer isso, a ConnectionStrings está com problemas.

 Comando alternativo para o Update-Database é o => dotnet ef database update no console e não no PM, após executar o comando
 podemos verificar no menu SQL Server Object Explorer, que pode ser acessado no visual studio através do menu View, que o banco
 e a tabela da nossa entidade foram criados.

 ====== Definindo os Action Results ======
 Neste ponto ja estamos com a API criada, EF configurado, Entidade criada e mapeada e o Banco de Dados Mapeado e Criado
 Agora partiremos para a manipulação dos registros através das operações via banco de dados. E isso será feito através das nossas
 Action Results da nossa Controller Produto.

 Criamos a controller com o nome ProdutosController.cs

 ====== Validando a entidade ======
 Nesta Aula, foi apresentado algumas formas alternativas e consideradas como boas práticas para a validação de entidades, onde não
 deixamos apenas como responsabilidade das data annotations, para isso fizemos um ajuste na nossa Program.cs onde no método/Service 
 AddControllers chamamos outro método ficando da seguinte forma abaixo, onde ela ignora os filtros de validação que adicionamos a 
 nossa model caso ela seja invalida.
 
 AddControllers().ConfigureApiBehaviorOptions(options =>
    {
        options.SuppressModelStateInvalidFilter = true; 
    });

pode parecer contráditório mas com essa configuração podemos adicionar melhores validações a nossas ActionResults como por exemplo
o que foi feito no método Post, onde validamos nossa ModelState caso seja invalidada, como está abaixo 3 exemplos, dessa forma
conseguimos retornar mais detalhes sobre o erro, até de forma personalizada, e tiramos a responsabilidade de ser totalmente das data
annotations.

if(!ModelState.IsValid) //Algumas formas de fazer nossas próprias validações
{
   //return BadRequest(ModelState); //funciona retorna os erros mas de forma simples.

   //return ValidationProblem(ModelState); //este é a boa pratica recomendada.

   return ValidationProblem(new ValidationProblemDetails(ModelState) //outra versão da boa pratica, só que personalizada
   {
       Title = "Um ou mais erros de validação ocorreram"
   });
}

 ====== Boas Praticas de Implementação ======
 Nesta aula realizamos a adoção de algumas boas praticas para nossa ProdutosController.cs, onde passamos alguns verificações
 para um retorno mais apropriado a cada situação, como por exemplo ao invés de retornar um null caso não exista a tabela Produtos
 retornamos um notfound, evitando o erro de nullPointer Exception, utilizamos esta abordagem no nosso método Get
if(_context.Produtos == null) //Evitando o erro de nullPointer exception
{
   return NotFound();
}

Já no nosso get por id, realizamos a abordagem acima e além dela, realizamos a abordagem abaixo, depois de realizar a consulta na tabela.
if (produto == null) //Evitando o erro de nullPointer exception caso não exista o produto com o ID solicitado
{
   return NotFound(); // se não existe retorna 404 not found
}

Para nosso Post usamos uma abordagem parecida, pois não adianta dar um Add na tabela se o produto não existe, vai acabar retornando um erro
500 retornando um null reference exception, e usando a forma abaixo isso é evitado e ainda da a oportunidade do cliente entrar em contato
e informar que a aplicação não está se comportando como deveria.
if(_context.Produtos == null)
{
   return Problem("Erro ao criar um produto, contate o suporte!");
}

Para o Put a abordagem mudou, primeiro substituimos o código de update na tabela deste abaixo
_context.Produtos.Update(produto); para este _context.Entry(produto).State = EntityState.Modified;
a diferença entre eles é que essa nova abordagem previne de um erro caracteristico do EF de entender que o objeto já foi manipulado em memória
e dizer que ele não pode atachar um objeto que já está atachado em memória, então o nosso novo código informa que o estado do objeto que estamos
enviando é modificado, então quando for feito o saveChanges ele já sabe que precisa realizar o update, então este caminho é o mais seguro.

Além disso fizemos a substituição do código await _context.SaveChangesAsync(); que salva as alterações no banco, por um try catch. Porque?
pois queremos evitar um problema de DbUpdateConcurrency, onde supondo que temos usuário A e B, o A está editando o produto Id 1 e manda salvar,
nesse mesmo tempo o B também mandou salvar, então chegam 2 solicitações de update ao mesmo tempo, isso pode dar o problema de concorrência no
banco de dados, para evitar este erro fazemos o tratamento do mesmo via o nosso Try Catch, por enquanto ficou desta forma
try
{
   await _context.SaveChangesAsync();
}
catch (DbUpdateConcurrencyException) 
{
   throw;
}

Porém antes mesmo de dar só um throw, seria interessante verificar se o produto existe, para dar um erro mais especifico. Então para isso criamos
após o nosso Delete, um método privado para fazer esta verificação. Segue abaixo.
private bool ProdutoExists(int id)
{
   return (_context.Produtos?.Any(e => e.Id == id)).GetValueOrDefault(); //O Any retorna um boolean, true ou false
}

após isso vamos utilizar este método junto com nosso try catch que fica da seguinte forma.
try
{
   await _context.SaveChangesAsync();
}
catch (DbUpdateConcurrencyException) 
{
   if (!ProdutoExists(id))
   {
      return NotFound();
   }
   else
   {
      throw;
   }
}

Agora no nosso Delete usamos as mesmas abordagens do nosso get por Id
Se a tabela não existir
if(_context.Produtos == null) 
{
   return NotFound();
}

Se o produto não existir
if (produto == null) 
{
   return NotFound();
}

E assim finalizamos a cobertura de boas práticas dos nossos requests, para melhorar ainda mais podemos ir ao nosso Projeto ApiFuncional e adicionar
ao <PropertyGroup> a seguinte configuração <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers> onde o código vai começar a reclamar, para adicionarmos
as Produces que são algumas data annotations para os retornos de códigos Http, adiciona abaixo dos [HttpGet, Post, Put e etc] as seguintes linhas
[ProducesResponseType(StatusCodes.Status204NoContent)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
[ProducesDefaultResponseType].